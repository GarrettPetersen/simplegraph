import math

from .base import BaseGraph
from .utils import hex_to_rgba
from .utils import is_dark


class BubbleAndArrowGraph(BaseGraph):
    """
    The graphs generated by this class feature bubbles and arrows. The bubbles
    and arrows are sized based on the data provided. The bubbles are colored
    based on the legend labels provided. The arrows are colored based on the
    data provided.
    """

    def __init__(
        self,
        width=300,
        height=200,
        padding=20,
        x_padding=None,
        y_padding=None,
        y_top_padding=None,
        y_bottom_padding=None,
        x_left_padding=None,
        x_right_padding=None,
        colors=None,
        num_y_ticks=5,
        x_axis_label=None,
        primary_y_axis_label=None,
        secondary_y_axis_label=None,
        show_legend=True,
        rotate_x_labels=True,
    ):
        super().__init__(
            width=width,
            height=height,
            padding=padding,
            x_padding=x_padding,
            y_padding=y_padding,
            y_top_padding=y_top_padding,
            y_bottom_padding=y_bottom_padding,
            x_left_padding=x_left_padding,
            x_right_padding=x_right_padding,
            colors=colors,
            num_y_ticks=num_y_ticks,
            x_axis_label=x_axis_label,
            primary_y_axis_label=primary_y_axis_label,
            secondary_y_axis_label=secondary_y_axis_label,
            show_legend=show_legend,
            rotate_x_labels=rotate_x_labels,
        )
        self.bubbles = []
        self.arrows = []
        self.cx = self.width / 2
        self.cy = self.height / 2

    def add_bubble(
        self,
        size,
        inner_size=None,
        text=None,
    ):
        self.bubbles.append((size, inner_size, text))

    def add_arrow(
        self,
        origin,
        destination,
        size,
    ):
        self.arrows.append((origin, destination, size))

    def _draw_dot(self, x, y, fill, radius=5, inner_radius=None, text=None):
        dot = f'<circle cx="{x}" cy="{y}" r="{radius}" fill="{fill}" />'
        if inner_radius:
            dot += f'<circle cx="{x}" cy="{y}" r="{inner_radius}" fill="white" />'
        if text:
            text_color = "white" if is_dark(fill) and not inner_radius else "black"
            dot += (
                f'<text x="{x}" y="{y}" text-anchor="middle" '
                + f'dominant-baseline="middle" fill="{text_color}">{text}</text>'
            )
        return dot

    def _draw_arrow(self, x1, y1, x2, y2, cx, cy, backoff, fill="black", width=1):
        arrow_head_length = max(10, width / 5)
        direction = math.atan2(y2 - cy, x2 - cx)
        perpendicular = direction + math.pi / 2
        x_offset = math.cos(perpendicular) * width / 2
        y_offset = math.sin(perpendicular) * width / 2

        # Calculate backoff
        backoff_x = math.cos(direction) * backoff
        backoff_y = math.sin(direction) * backoff

        # New position of x2, y2 after backoff
        x2_backoff = x2 - backoff_x
        y2_backoff = y2 - backoff_y

        # Arrow head with respect to the original x2, y2, but positioned at the backoff location
        x_arrow_head = x2_backoff - math.cos(direction) * arrow_head_length
        y_arrow_head = y2_backoff - math.sin(direction) * arrow_head_length

        # Control points for each side of the arrow, adjusted by half the width in the direction perpendicular to the arrow
        ctrl_x1 = cx + x_offset
        ctrl_y1 = cy + y_offset
        ctrl_x2 = cx - x_offset
        ctrl_y2 = cy - y_offset

        return (
            f'<path d="M {x1+x_offset},{y1+y_offset} '
            + f"Q{ctrl_x1},{ctrl_y1} {x_arrow_head + x_offset},{y_arrow_head + y_offset} "
            + f"L{x_arrow_head + 1.3 * x_offset},{y_arrow_head + 1.3 * y_offset} "
            + f"L{x2_backoff},{y2_backoff} L{x_arrow_head - 1.3 * x_offset},{y_arrow_head - 1.3 * y_offset} "
            + f"L{x_arrow_head - x_offset},{y_arrow_head - y_offset}"
            + f'Q{ctrl_x2},{ctrl_y2} {x1-x_offset},{y1-y_offset} z" '  # Z closes the path
            + f'fill="{hex_to_rgba(fill,0.5)}" />'
        )

    def _calculate_positions(self):
        inter_bubble_space = 0.1  # Proportional gap between bubbles

        # Calculate radii for all bubbles without scaling
        unscaled_bubbles = [
            (math.sqrt(bubble[0] / math.pi),) + bubble[1:] for bubble in self.bubbles
        ]

        # Distribute bubbles evenly around a circle
        num_bubbles = len(unscaled_bubbles)

        # Compute the minimum circle radius to avoid any overlap between bubbles
        min_circle_radius = (
            sum((1 + inter_bubble_space) * bubble[0] for bubble in unscaled_bubbles)
            / num_bubbles
            / math.sin(math.pi / num_bubbles)
        )
        largest_radii = sorted(bubble[0] for bubble in unscaled_bubbles)[-2:]
        min_circle_radius = max(
            min_circle_radius, sum(largest_radii) * (1 + inter_bubble_space)
        )

        # With this circle radius, determine the diameter and add some inter-bubble space
        min_diameter = 2 * (
            min_circle_radius + largest_radii[-1] * (1 + inter_bubble_space)
        )

        # Now compute the scaling factor to fit this minimum circle within the canvas
        scaling_factor = min(self.width, self.height) / min_diameter

        # Apply the scaling factor to the bubbles
        scaled_bubbles = [
            (bubble[0] * scaling_factor,) + bubble[1:] for bubble in unscaled_bubbles
        ]

        # Also scale the circle radius
        circle_radius = min_circle_radius * scaling_factor

        # Now that we have the circle radius and scaled bubbles, we can compute the bubble positions
        positions = []
        for i, bubble in enumerate(scaled_bubbles):
            angle = 2 * math.pi * i / num_bubbles  # Angle around circle
            bx = self.cx + circle_radius * math.cos(angle)  # Bubble x position
            by = self.cy + circle_radius * math.sin(angle)  # Bubble y position
            positions.append(
                (bx, by, bubble[0])
            )  # Append bubble center coordinates and radius

        return positions, scaling_factor

    def render(self):
        svg = f'<svg xmlns="http://www.w3.org/2000/svg" width="{self.width}" height="{self.height}">'

        positions, scaling_factor = self._calculate_positions()

        # Draw Arrows
        for arrow in self.arrows:
            origin = positions[arrow[0]]
            destination = positions[arrow[1]]
            backoff = positions[arrow[1]][2]
            size = arrow[2]
            width = 2 * math.sqrt(size / math.pi) * scaling_factor
            svg += self._draw_arrow(
                origin[0],
                origin[1],
                destination[0],
                destination[1],
                self.cx,
                self.cy,
                backoff,
                width=width,
                fill=self.colors[arrow[0]],
            )

        # Draw Bubbles
        for i, bubble in enumerate(self.bubbles):
            position = positions[i]
            inner_area = bubble[1] * scaling_factor if bubble[1] else None
            inner_radius = math.sqrt(inner_area / math.pi) if inner_area else None
            svg += self._draw_dot(
                position[0],
                position[1],
                self.colors[i],
                radius=position[2],
                inner_radius=inner_radius,
                text=bubble[2],
            )

        svg += "</svg>"
        return svg
